"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformVue = exports.uniAppUVuePlugin = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const compiler_sfc_1 = require("@vue/compiler-sfc");
const shared_1 = require("@vue/shared");
const uni_cli_shared_1 = require("@dcloudio/uni-cli-shared");
const gen_mapping_1 = require("@jridgewell/gen-mapping");
const trace_mapping_1 = require("@jridgewell/trace-mapping");
const descriptorCache_1 = require("./descriptorCache");
const utils_1 = require("../utils");
const script_1 = require("./code/script");
const template_1 = require("./code/template");
const style_1 = require("./code/style");
const utils_2 = require("./compiler/utils");
function uniAppUVuePlugin(opts) {
    const options = {
        root: process.env.UNI_INPUT_DIR,
        sourceMap: false,
        // eslint-disable-next-line no-restricted-globals
        compiler: require('@vue/compiler-sfc'),
        targetLanguage: process.env.UNI_UTS_TARGET_LANGUAGE,
    };
    const appVue = (0, uni_cli_shared_1.resolveAppVue)(process.env.UNI_INPUT_DIR);
    function isAppVue(id) {
        return (0, uni_cli_shared_1.normalizePath)(id) === appVue;
    }
    function normalizeEasyComSource(source) {
        // 把源码source调整为.uvue目录
        return (0, utils_1.parseUTSImportFilename)(source);
    }
    const autoImport = (0, utils_1.initAutoImportOnce)(opts.autoImportOptions);
    return {
        name: 'uni:app-uvue',
        apply: 'build',
        async resolveId(id) {
            // serve sub-part requests (*?vue) as virtual modules
            if ((0, uni_cli_shared_1.parseVueRequest)(id).query.vue) {
                return id;
            }
        },
        load(id) {
            const { filename, query } = (0, uni_cli_shared_1.parseVueRequest)(id);
            // select corresponding block for sub-part virtual modules
            if (query.vue) {
                if (query.src) {
                    return fs_extra_1.default.readFileSync(filename, 'utf-8');
                }
                const descriptor = (0, descriptorCache_1.getDescriptor)(filename, options);
                let block;
                if (query.type === 'style') {
                    block = descriptor.styles[query.index];
                }
                else if (query.index != null) {
                    block = descriptor.customBlocks[query.index];
                }
                if (block) {
                    return {
                        code: block.content,
                        map: block.map,
                    };
                }
            }
        },
        async transform(code, id) {
            const { filename, query } = (0, uni_cli_shared_1.parseVueRequest)(id);
            if (!(0, utils_1.isVue)(filename)) {
                return;
            }
            if (!query.vue) {
                // main request
                const { errors, uts, js, sourceMap } = await transformVue(code, filename, options, this, isAppVue, normalizeEasyComSource);
                if (errors.length) {
                    errors.forEach((error) => this.error((0, uni_cli_shared_1.createRollupError)('vue', filename, error, code)));
                    return null;
                }
                if (process.env.UNI_APP_X_TSC === 'true') {
                    return {
                        code: uts,
                        map: sourceMap,
                    };
                }
                const fileName = (0, utils_1.parseUTSRelativeFilename)(filename);
                this.emitFile({
                    type: 'asset',
                    fileName,
                    source: (await autoImport.transform(uts, id)).code,
                });
                if (sourceMap) {
                    this.emitFile({
                        type: 'asset',
                        fileName: (0, uni_cli_shared_1.removeExt)(fileName) + '.template.map',
                        source: JSON.stringify(sourceMap),
                    });
                }
                return {
                    code: js,
                };
            }
            else {
                // sub block request
                const descriptor = query.src
                    ? (0, descriptorCache_1.getSrcDescriptor)(filename)
                    : (0, descriptorCache_1.getDescriptor)(filename, options);
                if (query.type === 'style') {
                    return (0, style_1.transformStyle)(code, descriptor, Number(query.index), options, this, filename);
                }
            }
        },
        generateBundle(_, bundle) {
            // 遍历vue文件，填充style，尽量减少全局变量
            Object.keys(bundle).forEach((name) => {
                const file = bundle[name];
                if (file &&
                    file.type === 'asset' &&
                    (0, utils_1.isVue)(file.fileName) &&
                    (0, shared_1.isString)(file.source)) {
                    const fileName = (0, uni_cli_shared_1.normalizePath)(file.fileName);
                    const classNameComment = `/*${(0, utils_1.genClassName)(fileName, options.classNamePrefix)}Styles*/`;
                    if (file.source.includes(classNameComment)) {
                        const styleAssetName = fileName + '.style.uts';
                        const styleAsset = bundle[styleAssetName];
                        if (styleAsset &&
                            styleAsset.type === 'asset' &&
                            (0, shared_1.isString)(styleAsset.source)) {
                            file.source = file.source.replace(classNameComment, styleAsset.source.replace('export ', ''));
                            delete bundle[styleAssetName];
                        }
                    }
                }
            });
        },
    };
}
exports.uniAppUVuePlugin = uniAppUVuePlugin;
async function transformVue(code, filename, options, pluginContext, isAppVue = () => false, normalizeEasyComSource) {
    if (!options.compiler) {
        options.compiler = require('@vue/compiler-sfc');
    }
    code = code.replace(/\r\n/g, '\n');
    // prev descriptor is only set and used for hmr
    const { descriptor, errors } = (0, descriptorCache_1.createDescriptor)(filename, code, options);
    if (errors.length) {
        return { errors, descriptor };
    }
    const isApp = isAppVue(filename);
    const relativeFileName = (0, uni_cli_shared_1.normalizePath)(path_1.default.relative(options.root, filename));
    const className = (0, utils_1.genClassName)(relativeFileName, options.classNamePrefix);
    let templateCode = '';
    let templateImportsCode = '';
    let templateImportEasyComponentsCode = '';
    let templateImportUTSComponentsCode = '';
    const needSourceMap = process.env.UNI_APP_X_TEMPLATE_SOURCEMAP
        ? true
        : process.env.NODE_ENV !== 'production';
    let templateSourceMap;
    const templateStartLine = descriptor.template?.loc.start.line ?? 0;
    if (!isApp) {
        const inputRoot = (0, uni_cli_shared_1.normalizePath)(options.root);
        const templateResult = (0, template_1.genTemplate)(descriptor, {
            rootDir: options.root,
            targetLanguage: options.targetLanguage,
            mode: 'function',
            filename: relativeFileName,
            className: className,
            prefixIdentifiers: true,
            // 方便测试，build模式也提供sourceMap
            // sourceMap: false,
            sourceMap: needSourceMap,
            matchEasyCom: (tag, uts) => {
                const source = (0, uni_cli_shared_1.matchEasycom)(tag);
                if (uts && source) {
                    if (source.startsWith(inputRoot)) {
                        return '@/' + (0, uni_cli_shared_1.normalizePath)(path_1.default.relative(inputRoot, source));
                    }
                    return normalizeEasyComSource(source);
                }
                return source;
            },
            onWarn(warning) {
                console.warn('warning: ' + warning.message);
                if (warning.loc) {
                    const start = warning.loc.start;
                    console.log('at ' +
                        relativeFileName +
                        ':' +
                        (start.line + templateStartLine - 1) +
                        ':' +
                        (start.column - 1));
                    console.log((0, uni_cli_shared_1.generateCodeFrame)(code, {
                        line: start.line + templateStartLine - 1,
                        column: start.column - 1,
                    }).replace(/\t/g, ' '));
                }
            },
            onError(error) {
                console.error('error: ' + error.message);
                if (error.loc) {
                    const start = error.loc.start;
                    console.log('at ' +
                        relativeFileName +
                        ':' +
                        (start.line + templateStartLine - 1) +
                        ':' +
                        (start.column - 1));
                    console.log((0, uni_cli_shared_1.generateCodeFrame)(code, {
                        line: start.line + templateStartLine - 1,
                        column: start.column - 1,
                    }).replace(/\t/g, ' '));
                }
            },
            parseUTSComponent: uni_cli_shared_1.parseUTSComponent,
        });
        if (pluginContext && templateResult.ast) {
            await checkTemplateImports(templateResult.ast, async (importItem) => {
                if ((0, shared_1.isString)(importItem.exp)) {
                    return;
                }
                const resolved = await (0, utils_1.wrapResolve)(pluginContext.resolve)(importItem.path, filename);
                if (!resolved) {
                    const { start, end } = importItem.exp.loc;
                    start.line = start.line + templateStartLine - 1;
                    end.line = end.line + templateStartLine - 1;
                    throw (0, utils_1.createResolveError)(descriptor.source, (0, uni_cli_shared_1.createResolveErrorMsg)(importItem.path, filename), start, end);
                }
            });
        }
        Object.keys(templateResult.easyComponentAutoImports).forEach((source) => {
            (0, utils_1.addAutoImports)(source, templateResult.easyComponentAutoImports[source]);
        });
        templateCode = templateResult.code;
        templateImportEasyComponentsCode =
            templateResult.importEasyComponents.join('\n');
        templateImportUTSComponentsCode =
            templateResult.importUTSComponents.join('\n');
        templateImportsCode = templateResult.imports.join('\n');
        templateSourceMap = templateResult.map;
        if (process.env.NODE_ENV === 'production') {
            (0, utils_1.addExtApiComponents)(templateResult.elements.filter((element) => {
                // 如果是UTS原生组件，则无需记录摇树
                if ((0, uni_cli_shared_1.parseUTSComponent)(element, 'kotlin')) {
                    return false;
                }
                return true;
            }));
        }
    }
    // 生成 script 文件
    // console.log(descriptor.script?.loc)
    const utsCode = (0, script_1.genScript)(descriptor, { filename: className }) +
        templateCode +
        '\n' +
        (0, style_1.genStyle)(descriptor, { filename: relativeFileName, className }) +
        '\n';
    let jsCodes = [
        templateImportEasyComponentsCode,
        templateImportUTSComponentsCode,
        templateImportsCode,
    ];
    const content = descriptor.script?.content;
    if (content) {
        jsCodes.push(await (0, utils_1.parseImports)(content, pluginContext
            ? (0, utils_1.createTryResolve)(filename, pluginContext.resolve.bind(pluginContext), descriptor.script?.loc.start, descriptor.source)
            : undefined));
    }
    if (descriptor.styles.length) {
        jsCodes.push(await (0, style_1.genJsStylesCode)(descriptor, pluginContext));
    }
    jsCodes.push(`export default "${className}"
export const ${(0, utils_2.genComponentPublicInstanceImported)(options.root, relativeFileName)} = {}`);
    const jsCode = jsCodes.filter(Boolean).join('\n');
    return {
        errors: [],
        uts: utsCode,
        js: jsCode,
        descriptor,
        sourceMap: needSourceMap
            ? createSourceMap(descriptor.script?.loc.end.line ?? 0, templateStartLine, createVueSourceMap(relativeFileName, code, descriptor), templateSourceMap)
            : undefined,
    };
}
exports.transformVue = transformVue;
function createVueSourceMap(fileName, code, descriptor) {
    const str = new compiler_sfc_1.MagicString(code);
    if (descriptor.script) {
        const start = descriptor.script.loc.start;
        const end = descriptor.script.loc.end;
        str.overwrite(0, start.offset, '\n'.repeat(start.line - 1));
        str.remove(end.offset, code.length);
    }
    return str.generateMap({
        hires: true,
        source: fileName,
        includeContent: true,
    });
}
function createSourceMap(scriptCodeOffset, templateCodeOffset, vueMap, templateMap) {
    if (!templateMap) {
        return vueMap;
    }
    const gen = (0, gen_mapping_1.fromMap)(
    // version property of result.map is declared as string
    // but actually it is `3`
    vueMap);
    const tracer = new trace_mapping_1.TraceMap(
    // same above
    templateMap);
    // const offset = (scriptCode.match(/\r?\n/g)?.length ?? 0) + 1
    (0, trace_mapping_1.eachMapping)(tracer, (m) => {
        if (m.source == null)
            return;
        (0, gen_mapping_1.addMapping)(gen, {
            source: m.source,
            original: {
                line: m.originalLine + templateCodeOffset - 1,
                column: m.originalColumn,
            },
            generated: {
                line: m.generatedLine + scriptCodeOffset,
                column: m.generatedColumn,
            },
        });
    });
    return (0, gen_mapping_1.toEncodedMap)(gen);
}
async function checkTemplateImports(ast, tryResolve) {
    for (let importItem of ast.imports) {
        if (!(0, shared_1.isString)(importItem.exp)) {
            await tryResolve(importItem);
        }
    }
}
